# 📘 마스터링 MongoDB 7.0 - 10장: 인덱스 최적화 (Index Optimization) #
---

## 1. 인덱스란?

- 인덱스는 **쿼리 속도를 향상**시키기 위해 사용됩니다.
- MongoDB는 기본적으로 **B-tree 기반 인덱스**를 사용합니다.
- 컬렉션당 최대 64개의 인덱스를 생성할 수 있습니다.

---

## 2. 인덱스의 종류

| 인덱스 유형           | 설명                                                                                                  |
|------------------|-----------------------------------------------------------------------------------------------------|
| **단일 필드 인덱스**    | 하나의 필드에 대한 기본 인덱스, 임베디드 필드의 인덱싱은 점 표기법으로 할 수 있음                                                     |
| **복합 인덱스**       | 두 개 이상의 필드를 인덱싱, 순서 중요                                                                              |
| **다중키 인덱스**      | 배열 저장 기능을 인덱싱 영역으로 확장. 인덱스당 하나의 배열만 포함할 수 있음                                                        |
| **커버드 쿼리**       | 인덱스만 사용하여 실행되며 개별 문서 검사가 불필요한 쿼리를 의미                                                                |
| **해시 인덱스**       | 필드값을 해시를 저장. 정확한 일치 검색에 최적화된 성능. 범위기반 검색지원 안함. 복합 해시 인덱스. 다른 성능 최적화 완료 후 고려.                        |
| **텍스트 인덱스**      | 문자열 값을 포함하는 필드를 위한 특수한 인덱스. text 키워드 사용. 하나의 컬렉션에는 단일 텍스트 인덱스. 필드별 가중치                              |
| **아틀라스 검색 인덱스**  | 아파치 루씬 기반. 텍스트 인덱스보다 향상된 기능 제공. 13장에서 계속                                                            |
| **TTL 인덱스**      | 일정 시간이 지나면 문서를 자동 삭제, 날짜필드, 만료시간 지정                                                                 |
| **부분 인덱스**       | 조건을 충족하는 문서만 인덱싱. 최신 뉴스                                                      |
| **지리 공간 인덱스**    | 지리 정보를 활용한 애플리케이션 개발 지원. 2d - 2차원 / 2dsphere - 지구와 유사한 구면 표면. 기하학계산                                 |
| **와일드 카드 인덱스**   | (*)와일드카드 연산자를 이용한 유연한 필드 패턴을 정의.  필드 구조를 사전에 예측이 어려울때. 문서와 배열타입 속성을 재귀적 인덱싱하여 시스템 리소스 과도하게 사용할 수 있음 |
| **숨겨진 인덱스**      | 존재하지만, 몽고 쿼리 플래너에 감지되지 않음. 만료기간 문서 삭제. 고유성 보장 같은 기능을 수행하는 용도로 사용                                    |
| **복합 와일드카드 인덱스** | 7.0 이상에서 제공. 여러 필드 조합에 관한 고성능 쿼리를 지원                                                                |
---

## 모범사례 
- 인덱스 설계는 데이터베이스의 쿼리 성능과 전체적인 시스템의 효율성을 결정짓는 핵심 요소
- 다양한 사례에 대응 할 수 있는 포괄적인 인덱싱 옵션을 제공
- 무분별한 인덱스 생성이나 부적절한 인덱스 설계는 오히려 성능 저하를 초래 
- 선택성
  - 특정 인덱스값에 연결된 문서의 수를 나타내는 지표
  - 많은 고유값. 적은 중복값. 카디널리티
  - 카디널리티와 전체 문서 수의 비율로 계싼
- 선택성 높은 인덱스는 필요한 데이터를 빠르게 식별할 수 있어 효율적인 쿼리 실행을 가능하게 한다.

## 주요 명령어

### 인덱스 생성
```
db.collection.createIndex({ field1: 1, field2: -1 })
```
- 1: 오름차순, -1: 내림차순
- 운영 중에는 트래픽이 적은 시간대에 인덱스 생성 권장
- db.collection.getIndexes()로 현재 인덱스 목록 확인

### 인덱스 성능 분석
   📌 explain()
```
   db.collection.find({ field: value }).explain("executionStats")
```
- 실행 계획과 실제 인덱스 사용 여부 확인 가능
- 다음 항목 확인:
  - stage: COLLSCAN vs IXSCAN
  - nReturned: 반환 문서 수
  - executionTimeMillis: 실행 시간

```
   db.collection.stats()
```
- 인덱스 크기, 사용량 확인

```
   db.collection.totalIndexSize()
```
- 전체 인덱스 크기 확인

## ✅ 요약

- 인덱스는 쿼리 성능의 핵심이며, 잘못 설계된 인덱스는 오히려 성능을 저하시킬 수 있음
- 실사용 쿼리 패턴 분석 후 복합 인덱스 설계
- explain()을 활용한 인덱스 효과 분석은 필수
- Partial, TTL, Wildcard 등 목적별 특화 인덱스를 상황에 맞게 사용